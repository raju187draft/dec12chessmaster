module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/querystring [external] (querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/fs/promises [external] (fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs/promises", () => require("fs/promises"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:stream/promises [external] (node:stream/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/promises", () => require("node:stream/promises"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/lib/chess-engine.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Chess piece types and board representation
__turbopack_context__.s([
    "coordsToSquare",
    ()=>coordsToSquare,
    "createInitialState",
    ()=>createInitialState,
    "gameStateToFEN",
    ()=>gameStateToFEN,
    "getAllLegalMoves",
    ()=>getAllLegalMoves,
    "getPieceAt",
    ()=>getPieceAt,
    "getValidMoves",
    ()=>getValidMoves,
    "isKingInCheck",
    ()=>isKingInCheck,
    "makeMove",
    ()=>makeMove,
    "moveToAlgebraic",
    ()=>moveToAlgebraic,
    "squareToCoords",
    ()=>squareToCoords
]);
const INITIAL_BOARD = [
    [
        {
            type: "r",
            color: "b"
        },
        {
            type: "n",
            color: "b"
        },
        {
            type: "b",
            color: "b"
        },
        {
            type: "q",
            color: "b"
        },
        {
            type: "k",
            color: "b"
        },
        {
            type: "b",
            color: "b"
        },
        {
            type: "n",
            color: "b"
        },
        {
            type: "r",
            color: "b"
        }
    ],
    [
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        },
        {
            type: "p",
            color: "b"
        }
    ],
    [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
    ],
    [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
    ],
    [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
    ],
    [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
    ],
    [
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        },
        {
            type: "p",
            color: "w"
        }
    ],
    [
        {
            type: "r",
            color: "w"
        },
        {
            type: "n",
            color: "w"
        },
        {
            type: "b",
            color: "w"
        },
        {
            type: "q",
            color: "w"
        },
        {
            type: "k",
            color: "w"
        },
        {
            type: "b",
            color: "w"
        },
        {
            type: "n",
            color: "w"
        },
        {
            type: "r",
            color: "w"
        }
    ]
];
function createInitialState() {
    return {
        board: INITIAL_BOARD.map((row)=>row.map((piece)=>piece ? {
                    ...piece
                } : null)),
        turn: "w",
        castling: {
            w: {
                k: true,
                q: true
            },
            b: {
                k: true,
                q: true
            }
        },
        enPassant: null,
        halfMoves: 0,
        fullMoves: 1,
        history: [],
        isCheck: false,
        isCheckmate: false,
        isStalemate: false,
        isDraw: false
    };
}
function squareToCoords(square) {
    const col = square.charCodeAt(0) - 97;
    const row = 8 - Number.parseInt(square[1]);
    return [
        row,
        col
    ];
}
function coordsToSquare(row, col) {
    return String.fromCharCode(97 + col) + (8 - row);
}
function getPieceAt(state, square) {
    const [row, col] = squareToCoords(square);
    return state.board[row]?.[col] ?? null;
}
function setPieceAt(board, square, piece) {
    const [row, col] = squareToCoords(square);
    board[row][col] = piece;
}
function cloneBoard(board) {
    return board.map((row)=>row.map((piece)=>piece ? {
                ...piece
            } : null));
}
function cloneState(state) {
    return {
        board: cloneBoard(state.board),
        turn: state.turn,
        castling: {
            w: {
                ...state.castling.w
            },
            b: {
                ...state.castling.b
            }
        },
        enPassant: state.enPassant,
        halfMoves: state.halfMoves,
        fullMoves: state.fullMoves,
        history: [
            ...state.history
        ],
        isCheck: state.isCheck,
        isCheckmate: state.isCheckmate,
        isStalemate: state.isStalemate,
        isDraw: state.isDraw
    };
}
// Get pseudo-legal moves (doesn't check for leaving king in check)
function getPseudoLegalMoves(state, square) {
    const piece = getPieceAt(state, square);
    if (!piece) return [];
    const [row, col] = squareToCoords(square);
    const moves = [];
    switch(piece.type){
        case "p":
            moves.push(...getPawnMoves(state, row, col, piece.color));
            break;
        case "n":
            moves.push(...getKnightMoves(state, row, col, piece.color));
            break;
        case "b":
            moves.push(...getBishopMoves(state, row, col, piece.color));
            break;
        case "r":
            moves.push(...getRookMoves(state, row, col, piece.color));
            break;
        case "q":
            moves.push(...getQueenMoves(state, row, col, piece.color));
            break;
        case "k":
            moves.push(...getKingMoves(state, row, col, piece.color));
            break;
    }
    return moves;
}
function getValidMoves(state, square) {
    const piece = getPieceAt(state, square);
    if (!piece || piece.color !== state.turn) return [];
    const moves = getPseudoLegalMoves(state, square);
    // Filter out moves that would leave king in check
    return moves.filter((to)=>{
        const testState = makeQuickMove(state, square, to);
        return !isKingInCheck(testState, piece.color);
    });
}
function getPawnMoves(state, row, col, color) {
    const moves = [];
    const direction = color === "w" ? -1 : 1;
    const startRow = color === "w" ? 6 : 1;
    // Forward move
    const newRow = row + direction;
    if (newRow >= 0 && newRow < 8 && !state.board[newRow][col]) {
        moves.push(coordsToSquare(newRow, col));
        // Double move from start
        if (row === startRow && !state.board[row + 2 * direction][col]) {
            moves.push(coordsToSquare(row + 2 * direction, col));
        }
    }
    // Captures
    for (const dc of [
        -1,
        1
    ]){
        const newCol = col + dc;
        if (newCol >= 0 && newCol < 8 && newRow >= 0 && newRow < 8) {
            const target = state.board[newRow]?.[newCol];
            if (target && target.color !== color) {
                moves.push(coordsToSquare(newRow, newCol));
            }
            // En passant
            if (state.enPassant === coordsToSquare(newRow, newCol)) {
                moves.push(coordsToSquare(newRow, newCol));
            }
        }
    }
    return moves;
}
function getKnightMoves(state, row, col, color) {
    const moves = [];
    const offsets = [
        [
            -2,
            -1
        ],
        [
            -2,
            1
        ],
        [
            -1,
            -2
        ],
        [
            -1,
            2
        ],
        [
            1,
            -2
        ],
        [
            1,
            2
        ],
        [
            2,
            -1
        ],
        [
            2,
            1
        ]
    ];
    for (const [dr, dc] of offsets){
        const newRow = row + dr;
        const newCol = col + dc;
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const target = state.board[newRow][newCol];
            if (!target || target.color !== color) {
                moves.push(coordsToSquare(newRow, newCol));
            }
        }
    }
    return moves;
}
function getSlidingMoves(state, row, col, color, directions) {
    const moves = [];
    for (const [dr, dc] of directions){
        let newRow = row + dr;
        let newCol = col + dc;
        while(newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8){
            const target = state.board[newRow][newCol];
            if (!target) {
                moves.push(coordsToSquare(newRow, newCol));
            } else {
                if (target.color !== color) {
                    moves.push(coordsToSquare(newRow, newCol));
                }
                break;
            }
            newRow += dr;
            newCol += dc;
        }
    }
    return moves;
}
function getBishopMoves(state, row, col, color) {
    return getSlidingMoves(state, row, col, color, [
        [
            -1,
            -1
        ],
        [
            -1,
            1
        ],
        [
            1,
            -1
        ],
        [
            1,
            1
        ]
    ]);
}
function getRookMoves(state, row, col, color) {
    return getSlidingMoves(state, row, col, color, [
        [
            -1,
            0
        ],
        [
            1,
            0
        ],
        [
            0,
            -1
        ],
        [
            0,
            1
        ]
    ]);
}
function getQueenMoves(state, row, col, color) {
    return [
        ...getBishopMoves(state, row, col, color),
        ...getRookMoves(state, row, col, color)
    ];
}
function getKingMoves(state, row, col, color) {
    const moves = [];
    const offsets = [
        [
            -1,
            -1
        ],
        [
            -1,
            0
        ],
        [
            -1,
            1
        ],
        [
            0,
            -1
        ],
        [
            0,
            1
        ],
        [
            1,
            -1
        ],
        [
            1,
            0
        ],
        [
            1,
            1
        ]
    ];
    for (const [dr, dc] of offsets){
        const newRow = row + dr;
        const newCol = col + dc;
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const target = state.board[newRow][newCol];
            if (!target || target.color !== color) {
                moves.push(coordsToSquare(newRow, newCol));
            }
        }
    }
    // Castling
    const castleRow = color === "w" ? 7 : 0;
    if (row === castleRow && col === 4 && !isKingInCheck(state, color)) {
        // Kingside
        if (state.castling[color].k && !state.board[castleRow][5] && !state.board[castleRow][6] && state.board[castleRow][7]?.type === "r") {
            const test1 = makeQuickMove(state, coordsToSquare(row, col), coordsToSquare(row, 5));
            const test2 = makeQuickMove(state, coordsToSquare(row, col), coordsToSquare(row, 6));
            if (!isKingInCheck(test1, color) && !isKingInCheck(test2, color)) {
                moves.push(coordsToSquare(castleRow, 6));
            }
        }
        // Queenside
        if (state.castling[color].q && !state.board[castleRow][3] && !state.board[castleRow][2] && !state.board[castleRow][1] && state.board[castleRow][0]?.type === "r") {
            const test1 = makeQuickMove(state, coordsToSquare(row, col), coordsToSquare(row, 3));
            const test2 = makeQuickMove(state, coordsToSquare(row, col), coordsToSquare(row, 2));
            if (!isKingInCheck(test1, color) && !isKingInCheck(test2, color)) {
                moves.push(coordsToSquare(castleRow, 2));
            }
        }
    }
    return moves;
}
function findKing(state, color) {
    for(let row = 0; row < 8; row++){
        for(let col = 0; col < 8; col++){
            const piece = state.board[row][col];
            if (piece?.type === "k" && piece.color === color) {
                return coordsToSquare(row, col);
            }
        }
    }
    return null;
}
function isKingInCheck(state, color) {
    const kingSquare = findKing(state, color);
    if (!kingSquare) return false;
    const [kingRow, kingCol] = squareToCoords(kingSquare);
    const enemyColor = color === "w" ? "b" : "w";
    // Check for attacks from each piece type
    // Knights
    const knightOffsets = [
        [
            -2,
            -1
        ],
        [
            -2,
            1
        ],
        [
            -1,
            -2
        ],
        [
            -1,
            2
        ],
        [
            1,
            -2
        ],
        [
            1,
            2
        ],
        [
            2,
            -1
        ],
        [
            2,
            1
        ]
    ];
    for (const [dr, dc] of knightOffsets){
        const r = kingRow + dr;
        const c = kingCol + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = state.board[r][c];
            if (piece?.type === "n" && piece.color === enemyColor) return true;
        }
    }
    // Pawns
    const pawnDir = color === "w" ? -1 : 1;
    for (const dc of [
        -1,
        1
    ]){
        const r = kingRow + pawnDir;
        const c = kingCol + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = state.board[r][c];
            if (piece?.type === "p" && piece.color === enemyColor) return true;
        }
    }
    // King (for proximity checks)
    const kingOffsets = [
        [
            -1,
            -1
        ],
        [
            -1,
            0
        ],
        [
            -1,
            1
        ],
        [
            0,
            -1
        ],
        [
            0,
            1
        ],
        [
            1,
            -1
        ],
        [
            1,
            0
        ],
        [
            1,
            1
        ]
    ];
    for (const [dr, dc] of kingOffsets){
        const r = kingRow + dr;
        const c = kingCol + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = state.board[r][c];
            if (piece?.type === "k" && piece.color === enemyColor) return true;
        }
    }
    // Sliding pieces (bishop, rook, queen)
    const diagonals = [
        [
            -1,
            -1
        ],
        [
            -1,
            1
        ],
        [
            1,
            -1
        ],
        [
            1,
            1
        ]
    ];
    const straights = [
        [
            -1,
            0
        ],
        [
            1,
            0
        ],
        [
            0,
            -1
        ],
        [
            0,
            1
        ]
    ];
    for (const [dr, dc] of diagonals){
        let r = kingRow + dr;
        let c = kingCol + dc;
        while(r >= 0 && r < 8 && c >= 0 && c < 8){
            const piece = state.board[r][c];
            if (piece) {
                if (piece.color === enemyColor && (piece.type === "b" || piece.type === "q")) {
                    return true;
                }
                break;
            }
            r += dr;
            c += dc;
        }
    }
    for (const [dr, dc] of straights){
        let r = kingRow + dr;
        let c = kingCol + dc;
        while(r >= 0 && r < 8 && c >= 0 && c < 8){
            const piece = state.board[r][c];
            if (piece) {
                if (piece.color === enemyColor && (piece.type === "r" || piece.type === "q")) {
                    return true;
                }
                break;
            }
            r += dr;
            c += dc;
        }
    }
    return false;
}
function makeQuickMove(state, from, to) {
    const newBoard = cloneBoard(state.board);
    const [fromRow, fromCol] = squareToCoords(from);
    const [toRow, toCol] = squareToCoords(to);
    const piece = state.board[fromRow][fromCol];
    if (!piece) return state;
    newBoard[toRow][toCol] = {
        ...piece
    };
    newBoard[fromRow][fromCol] = null;
    // Handle en passant capture
    if (piece.type === "p" && to === state.enPassant) {
        const captureRow = piece.color === "w" ? toRow + 1 : toRow - 1;
        newBoard[captureRow][toCol] = null;
    }
    // Handle castling rook movement
    if (piece.type === "k" && Math.abs(toCol - fromCol) === 2) {
        if (toCol === 6) {
            newBoard[fromRow][5] = newBoard[fromRow][7];
            newBoard[fromRow][7] = null;
        } else if (toCol === 2) {
            newBoard[fromRow][3] = newBoard[fromRow][0];
            newBoard[fromRow][0] = null;
        }
    }
    return {
        ...state,
        board: newBoard,
        turn: state.turn === "w" ? "b" : "w"
    };
}
function makeMove(state, from, to, promotion) {
    const validMoves = getValidMoves(state, from);
    if (!validMoves.includes(to)) return null;
    const newState = cloneState(state);
    const [fromRow, fromCol] = squareToCoords(from);
    const piece = newState.board[fromRow][fromCol];
    if (!piece) return null;
    const [toRow, toCol] = squareToCoords(to);
    const captured = newState.board[toRow][toCol];
    // Create move record
    const move = {
        from,
        to,
        piece: piece.type,
        captured: captured?.type
    };
    // Handle special moves
    // En passant capture
    if (piece.type === "p" && to === state.enPassant) {
        const captureRow = piece.color === "w" ? toRow + 1 : toRow - 1;
        newState.board[captureRow][toCol] = null;
        move.enPassant = true;
        move.captured = "p";
    }
    // Castling
    if (piece.type === "k" && Math.abs(toCol - fromCol) === 2) {
        if (toCol === 6) {
            // Kingside
            newState.board[fromRow][5] = newState.board[fromRow][7];
            newState.board[fromRow][7] = null;
            move.castle = "k";
        } else if (toCol === 2) {
            // Queenside
            newState.board[fromRow][3] = newState.board[fromRow][0];
            newState.board[fromRow][0] = null;
            move.castle = "q";
        }
    }
    // Pawn promotion
    if (piece.type === "p" && (toRow === 0 || toRow === 7)) {
        piece.type = promotion || "q";
        move.promotion = piece.type;
    }
    // Move the piece
    newState.board[toRow][toCol] = piece;
    newState.board[fromRow][fromCol] = null;
    // Update castling rights
    if (piece.type === "k") {
        newState.castling[piece.color].k = false;
        newState.castling[piece.color].q = false;
    }
    if (piece.type === "r") {
        if (fromCol === 0) newState.castling[piece.color].q = false;
        if (fromCol === 7) newState.castling[piece.color].k = false;
    }
    // Set en passant square
    if (piece.type === "p" && Math.abs(toRow - fromRow) === 2) {
        newState.enPassant = coordsToSquare((fromRow + toRow) / 2, fromCol);
    } else {
        newState.enPassant = null;
    }
    // Update move counters
    if (piece.type === "p" || captured) {
        newState.halfMoves = 0;
    } else {
        newState.halfMoves++;
    }
    if (piece.color === "b") {
        newState.fullMoves++;
    }
    // Switch turn
    newState.turn = piece.color === "w" ? "b" : "w";
    // Check for check/checkmate/stalemate
    newState.isCheck = isKingInCheck(newState, newState.turn);
    move.check = newState.isCheck;
    const hasLegalMoves = hasAnyLegalMove(newState);
    if (!hasLegalMoves) {
        if (newState.isCheck) {
            newState.isCheckmate = true;
            move.checkmate = true;
        } else {
            newState.isStalemate = true;
        }
    }
    // Check for draw by 50-move rule
    if (newState.halfMoves >= 100) {
        newState.isDraw = true;
    }
    newState.history = [
        ...state.history,
        move
    ];
    return newState;
}
function hasAnyLegalMove(state) {
    for(let row = 0; row < 8; row++){
        for(let col = 0; col < 8; col++){
            const piece = state.board[row][col];
            if (piece && piece.color === state.turn) {
                const square = coordsToSquare(row, col);
                const moves = getPseudoLegalMoves(state, square);
                for (const to of moves){
                    const testState = makeQuickMove(state, square, to);
                    if (!isKingInCheck(testState, piece.color)) {
                        return true // Found at least one legal move
                        ;
                    }
                }
            }
        }
    }
    return false;
}
function getAllLegalMoves(state) {
    const moves = [];
    for(let row = 0; row < 8; row++){
        for(let col = 0; col < 8; col++){
            const piece = state.board[row][col];
            if (piece && piece.color === state.turn) {
                const square = coordsToSquare(row, col);
                const validMoves = getValidMoves(state, square);
                for (const to of validMoves){
                    moves.push({
                        from: square,
                        to
                    });
                }
            }
        }
    }
    return moves;
}
function moveToAlgebraic(state, move) {
    const pieceSymbols = {
        p: "",
        n: "N",
        b: "B",
        r: "R",
        q: "Q",
        k: "K"
    };
    if (move.castle === "k") return "O-O";
    if (move.castle === "q") return "O-O-O";
    let notation = pieceSymbols[move.piece];
    if (move.captured) {
        if (move.piece === "p") {
            notation += move.from[0];
        }
        notation += "x";
    }
    notation += move.to;
    if (move.promotion) {
        notation += "=" + pieceSymbols[move.promotion];
    }
    if (move.checkmate) {
        notation += "#";
    } else if (move.check) {
        notation += "+";
    }
    return notation;
}
function gameStateToFEN(state) {
    const pieceToFEN = {
        wp: "P",
        wn: "N",
        wb: "B",
        wr: "R",
        wq: "Q",
        wk: "K",
        bp: "p",
        bn: "n",
        bb: "b",
        br: "r",
        bq: "q",
        bk: "k"
    };
    let fen = "";
    // Board position
    for(let row = 0; row < 8; row++){
        let empty = 0;
        for(let col = 0; col < 8; col++){
            const piece = state.board[row][col];
            if (piece) {
                if (empty > 0) {
                    fen += empty;
                    empty = 0;
                }
                fen += pieceToFEN[piece.color + piece.type];
            } else {
                empty++;
            }
        }
        if (empty > 0) fen += empty;
        if (row < 7) fen += "/";
    }
    fen += " " + state.turn;
    let castling = "";
    if (state.castling.w.k) castling += "K";
    if (state.castling.w.q) castling += "Q";
    if (state.castling.b.k) castling += "k";
    if (state.castling.b.q) castling += "q";
    fen += " " + (castling || "-");
    fen += " " + (state.enPassant || "-");
    fen += " " + state.halfMoves;
    fen += " " + state.fullMoves;
    return fen;
}
}),
"[project]/app/api/analyze-move/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST,
    "maxDuration",
    ()=>maxDuration
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/genai/dist/node/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$chess$2d$engine$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/chess-engine.ts [app-route] (ecmascript)");
;
;
const maxDuration = 30;
function getMoveScore(type) {
    switch(type){
        case "brilliant":
            return 1.0;
        case "excellent":
            return 1.0;
        case "good":
            return 0.9;
        case "inaccuracy":
            return 0.5;
        case "mistake":
            return 0.25;
        case "blunder":
            return 0.0;
        default:
            return 0.75;
    }
}
function getALMLScore(centipawnLoss) {
    // 0 cp loss = 100, 300+ cp loss = 0
    const score = Math.max(0, Math.min(100, 100 - centipawnLoss / 3));
    return Math.round(score);
}
async function POST(req) {
    const { gameState, evaluation, moveHistory, playerStats, allEvaluations, moveTimes } = await req.json();
    const fen = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$chess$2d$engine$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["gameStateToFEN"])(gameState);
    const evaluations = allEvaluations || [
        evaluation
    ];
    const scores = evaluations.map((e)=>getMoveScore(e.type));
    const ams = scores.length > 0 ? scores.reduce((a, b)=>a + b, 0) / scores.length : 0.75;
    const mean = ams;
    const variance = scores.length > 1 ? scores.reduce((sum, s)=>sum + Math.pow(s - mean, 2), 0) / scores.length : 0;
    const stdDeviation = Math.sqrt(variance);
    // Count move types
    const blunders = evaluations.filter((e)=>e.type === "blunder").length;
    const mistakes = evaluations.filter((e)=>e.type === "mistake").length;
    const inaccuracies = evaluations.filter((e)=>e.type === "inaccuracy").length;
    const excellentMoves = evaluations.filter((e)=>e.type === "excellent" || e.type === "brilliant").length;
    // Average time per move
    const avgTimePerMove = moveTimes && moveTimes.length > 0 ? moveTimes.reduce((a, b)=>a + b, 0) / moveTimes.length : 0;
    // ALML score for current move
    const almlScore = getALMLScore(evaluation.centipawnLoss || 0);
    const prompt = `You are a chess coach analyzing a player's move. Be encouraging but honest.

Current position (FEN): ${fen}
Move played: ${evaluation.from} to ${evaluation.to}
Move evaluation: ${evaluation.type}
Centipawn loss: ${evaluation.centipawnLoss || 0} cp
ALML Score: ${almlScore}/100
${evaluation.bestMove ? `Better move was: ${evaluation.bestMove.from} to ${evaluation.bestMove.to}` : ""}
Recent moves: ${moveHistory.slice(-10).join(", ") || "Game just started"}
Player ELO rating: ~${playerStats?.skillRating || 1000}
Player accuracy this game: ${playerStats?.averageAccuracy || 70}%

Game Statistics:
- Average Move Score (AMS): ${ams.toFixed(3)} (${ams >= 0.9 ? "Excellent" : ams >= 0.75 ? "Great" : ams >= 0.5 ? "Good" : "Needs Improvement"})
- Standard Deviation: ${stdDeviation.toFixed(3)}
- Blunders: ${blunders}, Mistakes: ${mistakes}, Inaccuracies: ${inaccuracies}
- Excellent Moves: ${excellentMoves}

Provide a brief, helpful comment (2-3 sentences max) about this move:
- If it's a blunder/mistake: Explain WHY it's bad and what tactical/strategic element they missed
- If it's an inaccuracy: Gently point out the better continuation
- If it's good/excellent/brilliant: Encourage them and explain what made it strong
- If there's a tactical theme (fork, pin, skewer, discovered attack, etc.), mention it
- Tailor your language to their skill level (simpler for lower ELO, more technical for higher)
- Be conversational and supportive, like a friendly coach

Response (keep it short and helpful):`;
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
    const ai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenAI"]({
        apiKey: GEMINI_API_KEY
    });
    try {
        const { text } = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt
        });
        return Response.json({
            analysis: text,
            stats: {
                ams,
                amsLabel: ams >= 0.9 ? "Excellent" : ams >= 0.75 ? "Great" : ams >= 0.5 ? "Good" : "Needs Improvement",
                stdDeviation,
                avgTimePerMove,
                blunders,
                mistakes,
                inaccuracies,
                excellentMoves,
                almlScore
            }
        });
    } catch (error) {
        console.error("AI analysis error:", error);
        const fallback = getFallbackAnalysis(evaluation);
        return Response.json({
            analysis: fallback,
            stats: {
                ams,
                amsLabel: ams >= 0.9 ? "Excellent" : ams >= 0.75 ? "Great" : ams >= 0.5 ? "Good" : "Needs Improvement",
                stdDeviation,
                avgTimePerMove,
                blunders,
                mistakes,
                inaccuracies,
                excellentMoves,
                almlScore
            }
        });
    }
}
function getFallbackAnalysis(evaluation) {
    const cpLoss = evaluation.centipawnLoss || 0;
    switch(evaluation.type){
        case "brilliant":
            return "Brilliant! You found an exceptional move that significantly improves your position.";
        case "excellent":
            return "Excellent move! You're playing with great precision and understanding.";
        case "good":
            return "Solid move. Keep up the good play!";
        case "inaccuracy":
            return `Small inaccuracy (${cpLoss}cp loss). ${evaluation.bestMove ? `${evaluation.bestMove.from}-${evaluation.bestMove.to} would give you a slightly better position.` : "Look for more active moves."}`;
        case "mistake":
            return `That's a mistake (${cpLoss}cp loss). ${evaluation.bestMove ? `${evaluation.bestMove.from}-${evaluation.bestMove.to} was stronger.` : ""} Think about piece activity and king safety!`;
        case "blunder":
            return `Significant error (${cpLoss}cp loss)! ${evaluation.bestMove ? `${evaluation.bestMove.from}-${evaluation.bestMove.to} was much better.` : ""} Take your time and check for tactics before moving.`;
        default:
            return "Interesting move. Let's see how the game develops.";
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__d6bf1f00._.js.map